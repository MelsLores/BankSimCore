<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JwtUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.banksim.util</a> &gt; <span class="el_source">JwtUtil.java</span></div><h1>JwtUtil.java</h1><pre class="source lang-java linenums">package com.banksim.util;

import com.banksim.config.SecurityConfig;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.Instant;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

/**
 * JWT (JSON Web Token) utility for generating and validating authentication tokens.
 * Provides stateless authentication for REST API endpoints.
 * 
 * This is a simplified JWT implementation. For production, consider using
 * a library like jjwt (Java JWT) or auth0 java-jwt.
 * 
 * @author Jorge Pena - REM Consultancy
 * @version 1.0
 * @since 2024
 */
<span class="nc" id="L22">public class JwtUtil {</span>
    
<span class="nc" id="L24">    private static final SecurityConfig config = SecurityConfig.getInstance();</span>
    private static final String HEADER = &quot;{\&quot;alg\&quot;:\&quot;HS256\&quot;,\&quot;typ\&quot;:\&quot;JWT\&quot;}&quot;;
    
    /**
     * Generates a JWT token for a user
     * 
     * @param userId User ID
     * @param username Username
     * @param role User role
     * @return JWT token string
     */
    public static String generateToken(Integer userId, String username, String role) {
<span class="nc" id="L36">        long now = Instant.now().toEpochMilli();</span>
<span class="nc" id="L37">        long expirationTime = now + config.getJwtExpiration();</span>
        
<span class="nc" id="L39">        return generateToken(userId, username, role, expirationTime);</span>
    }
    
    /**
     * Generates a JWT token with custom expiration
     * 
     * @param userId User ID
     * @param username Username
     * @param role User role
     * @param expirationTime Expiration timestamp in milliseconds
     * @return JWT token string
     */
    public static String generateToken(Integer userId, String username, String role, long expirationTime) {
        try {
            // Create payload
<span class="nc" id="L54">            String payload = String.format(</span>
                &quot;{\&quot;sub\&quot;:\&quot;%d\&quot;,\&quot;username\&quot;:\&quot;%s\&quot;,\&quot;role\&quot;:\&quot;%s\&quot;,\&quot;iat\&quot;:%d,\&quot;exp\&quot;:%d}&quot;,
<span class="nc" id="L56">                userId, username, role, Instant.now().toEpochMilli(), expirationTime</span>
            );
            
            // Encode header and payload
<span class="nc" id="L60">            String encodedHeader = base64UrlEncode(HEADER);</span>
<span class="nc" id="L61">            String encodedPayload = base64UrlEncode(payload);</span>
            
            // Create signature
<span class="nc" id="L64">            String dataToSign = encodedHeader + &quot;.&quot; + encodedPayload;</span>
<span class="nc" id="L65">            String signature = createSignature(dataToSign);</span>
            
            // Return complete token
<span class="nc" id="L68">            return dataToSign + &quot;.&quot; + signature;</span>
            
<span class="nc" id="L70">        } catch (Exception e) {</span>
<span class="nc" id="L71">            throw new RuntimeException(&quot;Error generating JWT token&quot;, e);</span>
        }
    }
    
    /**
     * Generates a refresh token with extended expiration
     * 
     * @param userId User ID
     * @param username Username
     * @param role User role
     * @return Refresh token string
     */
    public static String generateRefreshToken(Integer userId, String username, String role) {
<span class="nc" id="L84">        long now = Instant.now().toEpochMilli();</span>
<span class="nc" id="L85">        long expirationTime = now + config.getJwtRefreshExpiration();</span>
        
<span class="nc" id="L87">        return generateToken(userId, username, role, expirationTime);</span>
    }
    
    /**
     * Validates a JWT token
     * 
     * @param token JWT token to validate
     * @return true if token is valid and not expired, false otherwise
     */
    public static boolean validateToken(String token) {
        try {
<span class="nc" id="L98">            String[] parts = token.split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">            if (parts.length != 3) {</span>
<span class="nc" id="L100">                return false;</span>
            }
            
            // Verify signature
<span class="nc" id="L104">            String dataToSign = parts[0] + &quot;.&quot; + parts[1];</span>
<span class="nc" id="L105">            String expectedSignature = createSignature(dataToSign);</span>
            
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (!constantTimeEquals(parts[2], expectedSignature)) {</span>
<span class="nc" id="L108">                return false;</span>
            }
            
            // Check expiration
<span class="nc" id="L112">            Map&lt;String, String&gt; claims = extractClaims(token);</span>
<span class="nc" id="L113">            long expiration = Long.parseLong(claims.get(&quot;exp&quot;));</span>
            
<span class="nc bnc" id="L115" title="All 2 branches missed.">            return Instant.now().toEpochMilli() &lt; expiration;</span>
            
<span class="nc" id="L117">        } catch (Exception e) {</span>
<span class="nc" id="L118">            return false;</span>
        }
    }
    
    /**
     * Extracts claims from a JWT token
     * 
     * @param token JWT token
     * @return Map of claim key-value pairs
     */
    public static Map&lt;String, String&gt; extractClaims(String token) {
<span class="nc" id="L129">        Map&lt;String, String&gt; claims = new HashMap&lt;&gt;();</span>
        
        try {
<span class="nc" id="L132">            String[] parts = token.split(&quot;\\.&quot;);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            if (parts.length != 3) {</span>
<span class="nc" id="L134">                return claims;</span>
            }
            
            // Decode payload
<span class="nc" id="L138">            String payload = base64UrlDecode(parts[1]);</span>
            
            // Parse JSON manually (simple key-value extraction)
<span class="nc" id="L141">            payload = payload.replace(&quot;{&quot;, &quot;&quot;).replace(&quot;}&quot;, &quot;&quot;).replace(&quot;\&quot;&quot;, &quot;&quot;);</span>
<span class="nc" id="L142">            String[] pairs = payload.split(&quot;,&quot;);</span>
            
<span class="nc bnc" id="L144" title="All 2 branches missed.">            for (String pair : pairs) {</span>
<span class="nc" id="L145">                String[] keyValue = pair.split(&quot;:&quot;, 2);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                if (keyValue.length == 2) {</span>
<span class="nc" id="L147">                    claims.put(keyValue[0].trim(), keyValue[1].trim());</span>
                }
            }
            
<span class="nc" id="L151">        } catch (Exception e) {</span>
            // Return empty claims on error
<span class="nc" id="L153">        }</span>
        
<span class="nc" id="L155">        return claims;</span>
    }
    
    /**
     * Extracts user ID from token
     * 
     * @param token JWT token
     * @return User ID or null if not found
     */
    public static Integer getUserId(String token) {
        try {
<span class="nc" id="L166">            Map&lt;String, String&gt; claims = extractClaims(token);</span>
<span class="nc" id="L167">            String sub = claims.get(&quot;sub&quot;);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            return sub != null ? Integer.parseInt(sub) : null;</span>
<span class="nc" id="L169">        } catch (Exception e) {</span>
<span class="nc" id="L170">            return null;</span>
        }
    }
    
    /**
     * Extracts username from token
     * 
     * @param token JWT token
     * @return Username or null if not found
     */
    public static String getUsername(String token) {
<span class="nc" id="L181">        Map&lt;String, String&gt; claims = extractClaims(token);</span>
<span class="nc" id="L182">        return claims.get(&quot;username&quot;);</span>
    }
    
    /**
     * Extracts user role from token
     * 
     * @param token JWT token
     * @return Role or null if not found
     */
    public static String getRole(String token) {
<span class="nc" id="L192">        Map&lt;String, String&gt; claims = extractClaims(token);</span>
<span class="nc" id="L193">        return claims.get(&quot;role&quot;);</span>
    }
    
    /**
     * Checks if token is expired
     * 
     * @param token JWT token
     * @return true if expired, false otherwise
     */
    public static boolean isTokenExpired(String token) {
        try {
<span class="nc" id="L204">            Map&lt;String, String&gt; claims = extractClaims(token);</span>
<span class="nc" id="L205">            long expiration = Long.parseLong(claims.get(&quot;exp&quot;));</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            return Instant.now().toEpochMilli() &gt;= expiration;</span>
<span class="nc" id="L207">        } catch (Exception e) {</span>
<span class="nc" id="L208">            return true;</span>
        }
    }
    
    /**
     * Creates HMAC-SHA256 signature for JWT
     * 
     * @param data Data to sign
     * @return Base64-URL encoded signature
     */
    private static String createSignature(String data) {
        try {
<span class="nc" id="L220">            String secret = config.getJwtSecret();</span>
<span class="nc" id="L221">            MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
            
            // Simple HMAC implementation
<span class="nc" id="L224">            String combined = data + secret;</span>
<span class="nc" id="L225">            byte[] hash = digest.digest(combined.getBytes(StandardCharsets.UTF_8));</span>
            
<span class="nc" id="L227">            return base64UrlEncode(hash);</span>
            
<span class="nc" id="L229">        } catch (Exception e) {</span>
<span class="nc" id="L230">            throw new RuntimeException(&quot;Error creating signature&quot;, e);</span>
        }
    }
    
    /**
     * Base64-URL encodes a string
     * 
     * @param input String to encode
     * @return Base64-URL encoded string
     */
    private static String base64UrlEncode(String input) {
<span class="nc" id="L241">        return base64UrlEncode(input.getBytes(StandardCharsets.UTF_8));</span>
    }
    
    /**
     * Base64-URL encodes a byte array
     * 
     * @param input Bytes to encode
     * @return Base64-URL encoded string
     */
    private static String base64UrlEncode(byte[] input) {
<span class="nc" id="L251">        return Base64.getUrlEncoder()</span>
<span class="nc" id="L252">                .withoutPadding()</span>
<span class="nc" id="L253">                .encodeToString(input);</span>
    }
    
    /**
     * Base64-URL decodes a string
     * 
     * @param input String to decode
     * @return Decoded string
     */
    private static String base64UrlDecode(String input) {
<span class="nc" id="L263">        byte[] decoded = Base64.getUrlDecoder().decode(input);</span>
<span class="nc" id="L264">        return new String(decoded, StandardCharsets.UTF_8);</span>
    }
    
    /**
     * Constant-time string comparison to prevent timing attacks
     * 
     * @param a First string
     * @param b Second string
     * @return true if strings are equal, false otherwise
     */
    private static boolean constantTimeEquals(String a, String b) {
<span class="nc bnc" id="L275" title="All 4 branches missed.">        if (a == null || b == null) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            return a == b;</span>
        }
        
<span class="nc" id="L279">        byte[] aBytes = a.getBytes(StandardCharsets.UTF_8);</span>
<span class="nc" id="L280">        byte[] bBytes = b.getBytes(StandardCharsets.UTF_8);</span>
        
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (aBytes.length != bBytes.length) {</span>
<span class="nc" id="L283">            return false;</span>
        }
        
<span class="nc" id="L286">        int result = 0;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        for (int i = 0; i &lt; aBytes.length; i++) {</span>
<span class="nc" id="L288">            result |= aBytes[i] ^ bBytes[i];</span>
        }
        
<span class="nc bnc" id="L291" title="All 2 branches missed.">        return result == 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>